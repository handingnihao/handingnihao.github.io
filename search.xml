<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[十条不错的编程观点]]></title>
    <url>%2FAndroid%2F%E5%8D%81%E6%9D%A1%E4%B8%8D%E9%94%99%E7%9A%84%E7%BC%96%E7%A8%8B%E8%A7%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[http://coolshell.cn/articles/2424.html 2010年5月14日陈皓发表评论阅读评论37,980 人阅读 在Stack Overflow上有这样的一个贴子《What’s your most controversial programming opinion?》，翻译成中文就是“你认为最有争议的编程观点是什么？”，不过，在400多个主回贴，以及千把个子回贴中，好像并不是很有争议，而是令人相当的茅塞顿开，下面罗列一些，并通过我自己的经历和理解发挥了一些，希望对你有帮助。 1） The only “best practice” you should be using all the time is “Use Your Brain”. 唯一的“Best Practice”并不是使用各种各样被前人总结过的各种设计方法、模式，框架，那些著名的方法、模式、框架只代码赞同他们的人多，并不代表他们适合你，你应该更多的去使用你的大脑，独立地思考那些方法、模式、框架出现的原因和其背后的想法和思想，那才是“best practice”。事实上来说，那些所谓的“Best Practice”只不过是限制那些糟糕的程序员们的破坏力。 2）Programmers who don’t code in their spare time for fun will never become as good as those that do. 如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的娱乐方式去生活，无论是编程，还是运动，还是去旅游，那么你只不过是在应付你的工作，无时无刻不扎在程序堆中，这样下来，就算是你是一个非常聪明，非常有才华的人，你也不会成为一个优秀的编程员，要么只会平平凡凡，要么只会整天扎在技术中成为书呆子。当然，这个观点是有争议，热情和能力的差距也是很大的。不过我们可以从中汲取其正面的观点。 3）Most comments in code are in fact a pernicious form of code duplication. 注释应该是注释Why，而不是How和What，参看《惹恼程序员的十件事》，代码告诉你How，而注释应该告诉你Why。但大多数的程序并不知道什么是好的注释，那些注释其实和code是重复的，毫无意义。 4）XML is highly overrated XML可能被高估了。XML对于Web上的应用是不错的，但是我们把其用到了各种地方，好像没有XML，我们都不会编程了。 5）Not all programmers are created equal 这是那些junior经理或是流程爱犯的错，他们总是认为，DeveloperA == DeveloperB，只要他们的title一样，他们以为他们的能力、工作速度、解决问题的方法，掌握的技能等等都是一样的。呵呵。更扯的是，在某些时候，就算是最差的程序员，他们也会认为其比别人强十倍，这就是现代的SB管理。 6）”Googling it” is okay! Google只会给你知识，并不会教给你技能。那里只有“鱼”，没有“渔”，过度的使用Google，只会让你越来越离不开他，你越来越去要去立马告诉你答案，而你越来越不会自己去思考，自己去探索，去专研。如果KFC快餐是垃圾食品对我们的身体没有好处，那么使用Google也一种快餐文化对我们的智力发展大大的没有好处。 7）If you only know one language, no matter how well you know it, you’re not a great programmer. 如果你只懂一种语言，准确的说，如果你只懂一类语类，如：Java和C#，PHP和Perl，那么，你将会被局限起来，只有了解了各种各样的语言，了解了不同语言的不同方法 ，你才会有比较，只有了比较，你才会明白各种语言的长处和短处，才会让你有更为成熟的观点，而且不整天和别的程序在网上斗嘴争论是Windows好还是Unix好，是C好还是C++好，有这点工夫能干好多事了。世界因为不同而精彩，只知道事物的一面是有害的。 8）Your job is to put yourself out of work. 你的工作不是保守，那种教会徒弟，饿死师父的想法，不但是相当短浅的，而且还是相当脑残的。因为，在计算机世界里，你掌握的老技术越多，你就越没用，因为技术更新的太快。你对工作越保守，这个工作就越来越离不开你，你就越不越不能抽身去学新的东西，你也就越来越OUT了。记住：If you can’t be replaced then you can’t be promoted! 9）Design patterns are hurting good design more than they’re helping it. 很多程序员把设计模式奉为天神，他们过度的追求设计模式以至都都忘了需求是什么，结果整个系统设计被设计模式搞得乱七八糟，我们叫这种编程为“设计模式驱动编程”，正如第一点所说，如果你不懂得用自己的大脑思考的话，知其然，不知所以然的话，那么你不但得不到其好处，反而受其所累。 10）Unit Testing won’t help you write good code 准确地说，我们可以认为这是Test-Driven开发，其实，这种开发就是先写unit test case，这样的开发方式的主要目的是，为了防止你不会因为一个改动而引入Bug，但这并不会让你能写出更好的代码。这只会让你写出不会出错的代码。同第一点，这样的方法，只不过是防止糟糕的程序员，而并不是让程序员或代码质量更有长进。反而，通过Unit Test会为程序员的为自己代码做辩解的一种托辞。 最后，顺便说一下，以前去那个敏捷的公司面试，发现那个公司的某些技术人员中毒不浅，具体表现在上述的1）9）10）观点上。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人人都有拖延症2]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F%2F%E6%96%B0%E7%94%B5%E8%84%91%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[今天说一下拖延症的话题啥是拖延症？简单来说，你有没有一件你一直想做，却因为各种原因拖着没做的事情，如果有，那就是拖延症。比如说，书柜里有没有一本你买了之后，一直都没看的书？如果有，那你就是拖延症的患者了。 人人都是完美主义者，总想用最短的时间获得最大的回报。我一直对自己说，公众号的文章不能再拖了，该更新了，但就是一直拖着没更。因为我认为自己还没准备好，我写出来的文章必须大家看了都点赞，是一篇“爆文”。正是这种心理拖着我一直没有去做。 很多时候我们是在为自己找借口，而且是很“合理”的借口。这其实是人的一种天然的懒惰心理，安于现状，最大限度的保护自己，却也让自己慢慢的倒退，失去了奋斗的意志。 市面上讲拖延症的书籍有一堆，治疗此病的方法也层出不穷。其实要我说，就几个字： 就是干 just do it 别想东想西的一大堆了，立马行动，哪怕是做了一点点，你就会一直做下去，拖延就不攻自破了。 [^欢迎关注微信公众号：]:]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文章注意事项]]></title>
    <url>%2Fothers%2F%E5%8F%91%E6%96%87%E7%AB%A0%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[1.打开Git Bash 2.切换到Hexo 所在目录，cd d:hexo 3.生成文章 hexo g 4.预览 hexo s （预览完要停止键盘按下 Ctrl + C 停止本地预览） 5.部署 hexo d -g 1&lt;!--more--&gt;]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人人都有拖延症]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F%2F%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%9C%89%E6%8B%96%E5%BB%B6%E7%97%87%2F</url>
    <content type="text"><![CDATA[今天说一下拖延症的话题啥是拖延症？简单来说，你有没有一件你一直想做，却因为各种原因拖着没做的事情，如果有，那就是拖延症。比如说，书柜里有没有一本你买了之后，一直都没看的书？如果有，那你就是拖延症的患者了。 人人都是完美主义者，总想用最短的时间获得最大的回报。我一直对自己说，公众号的文章不能再拖了，该更新了，但就是一直拖着没更。因为我认为自己还没准备好，我写出来的文章必须大家看了都点赞，是一篇“爆文”。正是这种心理拖着我一直没有去做。 很多时候我们是在为自己找借口，而且是很“合理”的借口。这其实是人的一种天然的懒惰心理，安于现状，最大限度的保护自己，却也让自己慢慢的倒退，失去了奋斗的意志。 市面上讲拖延症的书籍有一堆，治疗此病的方法也层出不穷。其实要我说，就几个字： 就是干 just do it 别想东想西的一大堆了，立马行动，哪怕是做了一点点，你就会一直做下去，拖延就不攻自破了。 [^欢迎关注微信公众号：]:]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android中MVP架构学习及使用(一)]]></title>
    <url>%2FAndroid%2FAndroid%E4%B8%ADMVP%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[先上一张图MVP的结构图 View:负责绘制UI元素、与用户交互(在Android中体现为Activity) Model:负责存储、检索、操作数据(有时实现一个Model Interface用来降低耦合) Presenter：作为View和Model交互的中间纽带，处理与用户交互的逻辑 View Interface：需要View实现的接口，View通过View Interface与Presenter进行交互，降低耦合度，方便单元测试 1&lt;!--more--&gt; 以下是谷歌官方的mvp项目架构实例，项目地址GitHub： https://github.com/googlesamples/android-architecture/tree/todo-mvp 基类 BaseBasePresenter 和 BaseView ，这两类分别是所有 Presenter 和 View 的基类。 12345678910public interface BasePresenter &#123; void start();&#125;public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; BasePresenter 中含有 start() 方法，该方法的作用是 presenter 开始获取数据，并调用 view 中的方法改变界面显示，其调用时机是在 Fragment 类的 onResume 方法中。 12345@Overridepublic void onResume() &#123; super.onResume(); mPresenter.start();&#125; BaseView 中含有方法 setPresenter ，该方法作用是在将 presenter 实例传入 view 中，其调用时机是 presenter 实现类的构造函数中。 123456public TasksPresenter(@NonNull TasksRepository tasksRepository, @NonNull TasksContract.View tasksView) &#123; mTasksRepository = checkNotNull(tasksRepository, "tasksRepository cannot be null"); mTasksView = checkNotNull(tasksView, "tasksView cannot be null!"); mTasksView.setPresenter(this);&#125; 契约类 Contract官方的实现中加入了契约类来统一管理 view 和 presenter 的所有接口，这种方式使得 view 和 presenter 中有哪些功能，一目了然，维护起来也方便，实现如下： 12345678910111213141516171819202122/** * This specifies the contract between the view and the presenter. */public interface TasksContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void setLoadingIndicator(boolean active); void showTasks(List&lt;Task&gt; tasks); ... &#125; interface Presenter extends BasePresenter &#123; void result(int requestCode, int resultCode); void loadTasks(boolean forceUpdate); ... &#125;&#125; activity 在 mvp 中的作用 activity 在项目中是一个全局的控制者，负责创建 view 以及 presenter 实例，并将二者联系起来，实现如下： 12345678910111213141516public class TasksActivity extends AppCompatActivity &#123; ... TasksFragment tasksFragment = (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame); if (tasksFragment == null) &#123; // Create the fragment tasksFragment = TasksFragment.newInstance(); ActivityUtils.addFragmentToActivity( getSupportFragmentManager(), tasksFragment, R.id.contentFrame); &#125; // Create the presenter mTasksPresenter = new TasksPresenter( Injection.provideTasksRepository(getApplicationContext()), tasksFragment); ...&#125; 创建后的 fragment 实例作为 presenter 的构造函数传入，这样就可以在 presenter 中调用 view 中的方法了。 mvp的实现实例中将fragment作为view层的实现类，为什么是fragment呢？有两个原因，第一个原因是我们把activity作为一个全局控制类来创建对象，把fragment作为view，这样两者就能各司其职。第二个原因是因为fragment比较灵活，能够方便的处理界面适配的问题。我们先看view的实现，我们只挑一部分重要的方法来看 上面可以看到setPresenter方法，该方法继承于父类，通过该方法，view获得了presenter得实例，从而可以调用presenter代码来处理业务逻辑。我们看到在onResume中还调用了presenter得start方法，下面我们再看presenter的实现 presenter 构造函数中调用了 view 的 setPresenter方法将自身实例传入，start 方法中处理了数据加载与展示。如果需要界面做对应的变化，直接调用 view 层的方法即可，这样 view 层与presenter 层就能够很好的被划分。 最后还剩下 model 层实现，项目中 model 层最大的特点是被赋予了数据获取的职责，与我们平常 model 层只定义实体对象截然不同，实例中，数据的获取、存储、数据状态变化都是 model 层的任务，presenter会根据需要调用该层的数据处理逻辑并在需要时将回调传入。这样 model、presenter、view都只处理各自的任务，此种实现确实是单一职责最好的诠释。 [^Android官方MVP架构示例项目解析\]:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
